<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FCIQMC Algorithm for the UEG: UEG_MAIN_binarytest.C File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FCIQMC Algorithm for the UEG
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">UEG_MAIN_binarytest.C File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;binaryManip.H&quot;</code><br/>
<code>#include &quot;planeWaves.H&quot;</code><br/>
<code>#include &quot;UEGHamiltonian.H&quot;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;set&gt;</code><br/>
<code>#include &lt;map&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc4e7d0bf8c76cb8b426703dc7115cdc"><td class="memItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#acc4e7d0bf8c76cb8b426703dc7115cdc">INLpow2</a> (std::uint64_t x)</td></tr>
<tr class="separator:acc4e7d0bf8c76cb8b426703dc7115cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3433e362b073bc05067375aa6b521a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a0d3433e362b073bc05067375aa6b521a">INLgetPositionInList</a> (std::pair&lt; long int, long int &gt; &amp;uniqueDet, std::vector&lt; long int &gt; &amp;alphaDetList, std::vector&lt; long int &gt; &amp;betaDetList)</td></tr>
<tr class="separator:a0d3433e362b073bc05067375aa6b521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc76e9bc36b9fb87b8c288f8888073c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a8fc76e9bc36b9fb87b8c288f8888073c">SPAWN</a> (const double cellLength, std::vector&lt; int &gt; &amp;trueWalkerList, std::vector&lt; int &gt; &amp;posWalkerList, std::vector&lt; int &gt; &amp;negWalkerList, double(&amp;KEsortedList)[ORB_SIZE][3], std::set&lt; std::pair&lt; long int, long int &gt; &gt; &amp;uniqueDetSet, std::pair&lt; std::set&lt; std::pair&lt; long int, long int &gt; &gt;::iterator, bool &gt; &amp;result, std::vector&lt; long int &gt; &amp;alphaDets, std::vector&lt; long int &gt; &amp;betaDets)</td></tr>
<tr class="separator:a8fc76e9bc36b9fb87b8c288f8888073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e83ca6bb3da729c527ddf6012aa98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a49e83ca6bb3da729c527ddf6012aa98f">DEATH_CLONE</a> (const double cellLength, std::vector&lt; int &gt; &amp;trueWalkerList, double(&amp;KEsortedList)[ORB_SIZE][3], double &amp;SHIFT, std::vector&lt; long int &gt; &amp;alphaDets, std::vector&lt; long int &gt; &amp;betaDets, const double &amp;HFEnergy)</td></tr>
<tr class="separator:a49e83ca6bb3da729c527ddf6012aa98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f327cb0a53f992caea1d8bee3816d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a87f327cb0a53f992caea1d8bee3816d8">ANNIHILATION</a> (int &amp;step, std::vector&lt; int &gt; &amp;trueWalkerList, std::vector&lt; int &gt; &amp;posWalkerList, std::vector&lt; int &gt; &amp;negWalkerList, std::set&lt; std::pair&lt; long int, long int &gt; &gt; &amp;uniqueDeterminantSet, std::vector&lt; long int &gt; &amp;alphaDetsBinary, std::vector&lt; long int &gt; &amp;betaDetsBinary)</td></tr>
<tr class="separator:a87f327cb0a53f992caea1d8bee3816d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e40179604d09f7f8b1266958b11d930"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a9e40179604d09f7f8b1266958b11d930">totalWalkerNumber</a> (std::vector&lt; int &gt; &amp;trueWalkerList)</td></tr>
<tr class="separator:a9e40179604d09f7f8b1266958b11d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec81bf6b6e5089a5647fb2c8205e1a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a0ec81bf6b6e5089a5647fb2c8205e1a6">variableShift</a> (const double &amp;<a class="el" href="UEG__MAIN__binarytest_8C.html#aa06f5594efa32a5569766c36690b4a22">delt</a>, const int &amp;<a class="el" href="UEG__MAIN__binarytest_8C.html#a1b1b50ff28122bf25bbd141938893243">AShift</a>, int &amp;intTimestep, const double &amp;<a class="el" href="UEG__MAIN__binarytest_8C.html#a50fb6782013c8c12243ca553cee0971a">zeta</a>, std::vector&lt; double &gt; &amp;totalWalkerTracker, std::vector&lt; double &gt; &amp;shiftTracker)</td></tr>
<tr class="separator:a0ec81bf6b6e5089a5647fb2c8205e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab516e26346b637d7482dc9043e806be2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#ab516e26346b637d7482dc9043e806be2">projectorEnergy</a> ()</td></tr>
<tr class="separator:ab516e26346b637d7482dc9043e806be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a952eac791b596a61bba0a133a3bb439f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a952eac791b596a61bba0a133a3bb439f">PI</a> = 3.141592653589793</td></tr>
<tr class="separator:a952eac791b596a61bba0a133a3bb439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363ad74e3d4570cd6bfaa4622e0af0bd"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a363ad74e3d4570cd6bfaa4622e0af0bd">rs</a> = 1.0</td></tr>
<tr class="separator:a363ad74e3d4570cd6bfaa4622e0af0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613e167ad809e33c73b70a24822cc6f9"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a613e167ad809e33c73b70a24822cc6f9">numElectrons</a> = 14</td></tr>
<tr class="separator:a613e167ad809e33c73b70a24822cc6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3e2699d268bc86fda1a7a41270c49e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#ace3e2699d268bc86fda1a7a41270c49e">INTelectrons</a> = <a class="el" href="UEG__MAIN__binarytest_8C.html#a613e167ad809e33c73b70a24822cc6f9">numElectrons</a></td></tr>
<tr class="separator:ace3e2699d268bc86fda1a7a41270c49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c8c523b8aaaef95263171d9b078d8d"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#aa8c8c523b8aaaef95263171d9b078d8d">Kc_CUTTOFF</a> = 2</td></tr>
<tr class="separator:aa8c8c523b8aaaef95263171d9b078d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f5594efa32a5569766c36690b4a22"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#aa06f5594efa32a5569766c36690b4a22">delt</a> = 0.003</td></tr>
<tr class="separator:aa06f5594efa32a5569766c36690b4a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fb6782013c8c12243ca553cee0971a"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a50fb6782013c8c12243ca553cee0971a">zeta</a> = 0.04</td></tr>
<tr class="separator:a50fb6782013c8c12243ca553cee0971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1b50ff28122bf25bbd141938893243"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a1b1b50ff28122bf25bbd141938893243">AShift</a> = 2</td></tr>
<tr class="separator:a1b1b50ff28122bf25bbd141938893243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957840dbdbfa8a29c76754be143dd02f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a957840dbdbfa8a29c76754be143dd02f">numSteps</a> = 500000</td></tr>
<tr class="separator:a957840dbdbfa8a29c76754be143dd02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7e0fd46bc659f43a5e2fe841b0aeeb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a6c7e0fd46bc659f43a5e2fe841b0aeeb">walkerCritical</a> = 500000</td></tr>
<tr class="separator:a6c7e0fd46bc659f43a5e2fe841b0aeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5481ef8ba617908ce12828cc4a8c45a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a5481ef8ba617908ce12828cc4a8c45a3">initRefWalkers</a> = 50</td></tr>
<tr class="separator:a5481ef8ba617908ce12828cc4a8c45a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4a522e121fab9651a940cabf5ac77d"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UEG__MAIN__binarytest_8C.html#a5a4a522e121fab9651a940cabf5ac77d">pow2Array</a> [ORB_SIZE]</td></tr>
<tr class="separator:a5a4a522e121fab9651a940cabf5ac77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a87f327cb0a53f992caea1d8bee3816d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ANNIHILATION </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>trueWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>posWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>negWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::pair&lt; long int, long int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniqueDeterminantSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaDetsBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>betaDetsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This represents the final (third) step in the population dynamics algorithm. The following description is verbatim from the original paper:</p>
<p>The annihilation step: In this (final) part of the algorithm, we run over all (newly-spawned, cloned and surviving parent) walkers, and annihilate pairs of walkers of opposite sign which are found to be on the same determinant. Each time an annihilation event occurs, the corresponding pair is removed from the list of walkers, and the total number of walkers <img class="formulaInl" alt="$ N_w $" src="form_20.png"/> reduced by two. </p>

</div>
</div>
<a class="anchor" id="a49e83ca6bb3da729c527ddf6012aa98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DEATH_CLONE </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cellLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>trueWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(&amp;)&#160;</td>
          <td class="paramname"><em>KEsortedList</em>[ORB_SIZE][3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>SHIFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaDets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>betaDets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>HFEnergy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine represents the second step in the population dynamics algorithm. The following description is verbatim from the original paper:</p>
<p>The diagonal death/cloning step: for each (parent) walker compute </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_{d}(i_{\alpha}) = \delta \tau( K_{i_{\alpha} i_{\alpha}} - S ) (16) \]" src="form_21.png"/>
</p>
<p>If <img class="formulaInl" alt="$ p_d > 0 $" src="form_14.png"/>, the walker dies with probability <img class="formulaInl" alt="$ p_d $" src="form_15.png"/>, and if <img class="formulaInl" alt="$ p_d < 0 $" src="form_16.png"/> the walker is cloned with probability <img class="formulaInl" alt="$ |pd| $" src="form_17.png"/>. The death event happens immediately, and such a parent does not participate in the following (annihilation) step to be described shortly. Cloning events are quite rare, and only occur for <img class="formulaInl" alt="$ S > 0 $" src="form_18.png"/>, and even then only on determinants for which <img class="formulaInl" alt="$ \langle D_i | K | D_i \rangle < S $" src="form_19.png"/> . In simulations where we desire to grow the number of walkers rapidly, a positive value of S is adopted, and this can lead to cloning events. However, more often, the value of S is negative (as it tries to match the correlation energy), and in such cases there can be no cloning events at all. </p>
<p>Generates a number between (0,1] </p>

</div>
</div>
<a class="anchor" id="a0d3433e362b073bc05067375aa6b521a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int INLgetPositionInList </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; long int, long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniqueDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaDetList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>betaDetList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function purely resturns the position of a unique determinant within the list of Alpha and Beta determinants. It is necessary to know this, in order that we can add a new walker to the correct determinant (Our unique list is not sorted according to the walker number list, but the Alpha and Beta lists ARE sorted to associate with the walker number list) </p>

</div>
</div>
<a class="anchor" id="acc4e7d0bf8c76cb8b426703dc7115cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t INLpow2 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simply raises the input argument to the power 2, thus returning <img class="formulaInl" alt="$ 2^x $" src="form_22.png"/> </p>

</div>
</div>
<a class="anchor" id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>M A I N - S T A R T S - H E R E </h2>

</div>
</div>
<a class="anchor" id="ab516e26346b637d7482dc9043e806be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double projectorEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Projector Energy gives an independent estimation of the energy from the shift, according to equation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_{proj} = \sum_{j \neq 0} \Big \langle D_j | H | D_0 \Big \rangle \frac{N_j (\tau)}{N_0 (\tau)} \]" src="form_1.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a8fc76e9bc36b9fb87b8c288f8888073c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPAWN </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cellLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>trueWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>posWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>negWalkerList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(&amp;)&#160;</td>
          <td class="paramname"><em>KEsortedList</em>[ORB_SIZE][3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::pair&lt; long int, long int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniqueDetSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::set&lt; std::pair&lt; long int, long int &gt; &gt;::iterator, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaDets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>betaDets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function represents first step in the population dynamics of the algorithm. The spawning routine goes as follows, described verbatim from the original paper:</p>
<p>The spawning step: for each walker <img class="formulaInl" alt="$ \alpha $" src="form_3.png"/> (located on <img class="formulaInl" alt="$ D_{i \alpha} $" src="form_4.png"/>), we select a (coupled) determinant <img class="formulaInl" alt="$ D_j $" src="form_5.png"/> with normalised probability pgen(j|iα) and attempt to spawn a child there with probability </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_s(j|i_{\alpha}) = \frac{\delta \tau | K_{i_{\alpha}j} | }{p_{gen}j | i_{\alpha}} (15) \]" src="form_6.png"/>
</p>
<p> If a spawning event is successful, (i.e. if ps exceeds a uniformly chosen random number between 0 and 1), then the sign of the child is determined by the sign of <img class="formulaInl" alt="$ K_{i_{\alpha}j} $" src="form_10.png"/> and the sign of the parent: it is the same sign as the parent if <img class="formulaInl" alt="$ K_{i_{\alpha}j} < 0 $" src="form_7.png"/> , and opposite to the parent otherwise. Our method to compute the generation probabilities <img class="formulaInl" alt="$ p_{gen} $" src="form_8.png"/> is given in Appendix B. If <img class="formulaInl" alt="$ p_s > 1 $" src="form_9.png"/> , then multiple copies of walkers are spawned on j (namely with probability 1, <img class="formulaInl" alt="$ |ps| $" src="form_11.png"/> walkers are spawned, and with probability <img class="formulaInl" alt="$ ps − |ps| $" src="form_12.png"/> an additional walker is spawned). </p>

</div>
</div>
<a class="anchor" id="a9e40179604d09f7f8b1266958b11d930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int totalWalkerNumber </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>trueWalkerList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simply counts the current number of walkers associated with all determinants, irrespective of sign. Returns: <img class="formulaInl" alt="$ N_w = \sum_{i} | N_i | $" src="form_24.png"/> </p>

</div>
</div>
<a class="anchor" id="a0ec81bf6b6e5089a5647fb2c8205e1a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double variableShift </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>delt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>AShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>intTimestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>zeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>totalWalkerTracker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>shiftTracker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>variableShift function controls the shift in response to the population, and relates exactly to the equation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ S(\tau) = S(\tau - A\delta \tau) - \frac{\zeta}{A \delta \tau} ln\frac{N_w (\tau)}{N_w (\tau - A\delta \tau)} \]" src="form_0.png"/>
</p>
 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a1b1b50ff28122bf25bbd141938893243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int AShift = 2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AShift controls how frequently the shift is changed in response to the population in the variable shift mode (AShift = 1 means every step) </p>

</div>
</div>
<a class="anchor" id="aa06f5594efa32a5569766c36690b4a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double delt = 0.003</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>delt is the Imaginary timestep for the propogation of the "walker" population </p>

</div>
</div>
<a class="anchor" id="a5481ef8ba617908ce12828cc4a8c45a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int initRefWalkers = 50</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>initRefWalkers is the number of wlakers which are initially placed on the reference (i.e Hartree Fock) determinant to begin the spawning </p>

</div>
</div>
<a class="anchor" id="ace3e2699d268bc86fda1a7a41270c49e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int INTelectrons = <a class="el" href="UEG__MAIN__binarytest_8C.html#a613e167ad809e33c73b70a24822cc6f9">numElectrons</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa8c8c523b8aaaef95263171d9b078d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double Kc_CUTTOFF = 2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Kc_CUTTOFF is the kinetic energy cutoff for the plane wave basis orbitals. E.g, a cutoff of "2" will allow the orbital [4 0 0] but not [5 0 0]. Set cutoff = 2.4 for 57 Orbitals (114 Spin Orbitals) </p>

</div>
</div>
<a class="anchor" id="a613e167ad809e33c73b70a24822cc6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double numElectrons = 14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of electrons -&gt; half allocated Alpha spin, the other half allocated Beta Spin. </p>

</div>
</div>
<a class="anchor" id="a957840dbdbfa8a29c76754be143dd02f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int numSteps = 500000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of steps after which to terminate the algorithm </p>

</div>
</div>
<a class="anchor" id="a952eac791b596a61bba0a133a3bb439f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double PI = 3.141592653589793</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A number, nobody knows what it means </p>

</div>
</div>
<a class="anchor" id="a5a4a522e121fab9651a940cabf5ac77d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int pow2Array[ORB_SIZE]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a363ad74e3d4570cd6bfaa4622e0af0bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double rs = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>rs controls density of the Electron Gas. "rs" is the radius of the sphere whose volume is that of the cell divided by the number of electrons </p>

</div>
</div>
<a class="anchor" id="a6c7e0fd46bc659f43a5e2fe841b0aeeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int walkerCritical = 500000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After "walker critical" walkers have been spawned after a complete cycle (post annihilation) the variable shift mode is turned on </p>

</div>
</div>
<a class="anchor" id="a50fb6782013c8c12243ca553cee0971a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double zeta = 0.04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeta is a damping parameter which controls the agressiveness of the "shift" in the variable shift mode of the algorithm </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 7 2017 18:16:11 for FCIQMC Algorithm for the UEG by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
